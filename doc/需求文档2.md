这份文档是 **PySpine3D 的最终执行版需求规格说明书 (SRS v2.0)**。

它融合了之前所有的讨论、技术决策、被遗漏的产品级功能（如撤销/重做、项目保存）、UI 现代化规范以及核心算法逻辑。

**请将这份文档直接交给你的开发工程师。** 它不仅仅是一份需求，更是一份开发指南。

---

# PySpine3D 软件需求规格说明书 (SRS v2.0)

**文档状态：** 执行版 (Execution Ready)
**适用对象：** Python 开发工程师 (中级及以上)
**项目目标：** 开发一款基于 EOS 正侧位 X 光影像的脊柱 3D 建模与测量软件，具备现代化的医疗软件界面，支持保存进度、导出报告及 3D 打印模型。

---

## 1. 系统架构与技术栈 (System Architecture)

### 1.1 推荐目录结构
为了保证代码的可维护性，强制要求遵循以下项目结构：

```text
PySpine3D/
├── assets/                 # 静态资源
│   ├── models/             # 标准脊柱模板 (T1.obj ... L5.obj, Pelvis.obj)
│   ├── icons/              # 矢量图标 (SVG)
│   └── themes/             # 自定义 QSS 样式表
├── src/
│   ├── main.py             # 程序入口
│   ├── core/               # 核心算法层 (无 UI)
│   │   ├── dicom_loader.py # 解析 EOS DICOM
│   │   ├── geometry.py     # 投影矩阵, 3D 数学计算
│   │   ├── measurements.py # Cobb角, PI, PT 计算
│   │   └── state.py        # 撤销/重做栈, 项目保存/加载
│   ├── gui/                # 界面层 (PyQt)
│   │   ├── main_window.py
│   │   ├── widgets/        # 自定义控件 (2D View, 3D View)
│   │   └── dialogs/        # 弹窗 (导出, 设置)
│   └── utils/              # 工具类 (日志, 异常处理)
├── logs/                   # 运行时日志
└── requirements.txt        # 依赖库
```

### 1.2 核心技术栈
*   **Python:** 3.10+
*   **GUI:** `PyQt6` (应用框架) + `qt-material` (现代化主题)
*   **3D Engine:** `pyvista` + `pyvistaqt` (基于 VTK 的渲染与交互)
*   **Math/Data:** `numpy` (矩阵运算), `scipy` (空间插值), `pydicom` (DICOM I/O)
*   **Utils:** `loguru` (日志), `json` (项目文件)

---

## 2. 非功能性需求 (Non-Functional Requirements)

### 2.1 UI/UX 现代化规范
*   **主题：** 强制使用 **Dark Medical** 风格。背景色 `#2B2B2B`，强调色 `#FF9500` (EOS Orange) 或 `#007AFF`。
*   **交互：**
    *   所有按钮必须有 Hover 状态变化。
    *   2D 视图操作：右键拖动平移，滚轮缩放，左键操作工具。
    *   3D 视图操作：左键旋转，Shift+左键平移，滚轮缩放。
*   **响应速度：** 拖动 3D 模型时，2D 投影线框的更新延迟需 < 30ms (30 FPS)。

### 2.2 UI 设计细节
*   **配色方案：**
    *   背景色：`#2B2B2B` (深炭灰)
    *   面板色：`#323232`
    *   强调色：`#FF9500` (EOS橙) 或 `#007AFF` (医疗蓝)
    *   文本色：`#FFFFFF` (主要), `#B0B0B0` (次要)
*   **布局与样式：**
    *   圆角：按钮和输入框采用 `4px-6px` 圆角
    *   图标：使用矢量图标（推荐 `qtawesome` 库）
    *   字体：Windows用 `Segoe UI`，Mac用 `SF Pro Display`，禁用衬线体
*   **交互优化：**
    *   Hover效果：按钮悬停时背景色变亮 (`#454545`)
    *   3D视图背景：使用深色渐变（顶部深灰到底部黑色）
    *   布局间距：适当增加控件间距

### 2.3 UI 库推荐
*   **qt-material:** 快速实现Material Design风格
  ```python
  from qt_material import apply_stylesheet
  apply_stylesheet(app, theme='dark_medical.xml')
  ```
*   **QDarkStyleSheet:** 经典深色主题

### 2.4 数据安全与稳定性
*   **项目文件 (.pspine):** 必须支持保存当前工作进度（包含加载的图片路径、所有控制点坐标、3D 模型变换矩阵）。格式为 JSON。
*   **异常捕获：** 全局 `try-except` 捕获未处理异常，弹窗提示用户并写入 `logs/error.log`，防止直接闪退。
*   **撤销/重做 (Undo/Redo):** 至少支持 10 步历史记录（主要针对控制点移动和椎体调整）。

---

## 3. 功能模块详解 (Functional Requirements)

### 模块 A: 数据加载与预处理
*   **A.1 智能加载:** 用户选择文件夹，程序自动扫描 `.dcm` 文件。
*   **A.2 自动分类:**
    *   读取 DICOM Tag `(0018, 9402)` (Distance Source to Isocenter)。
    *   较小值 (~918mm) 识别为 **Frontal (正位)**。
    *   较大值 (~987mm) 识别为 **Lateral (侧位)**。
*   **A.3 图像校正:** 自动读取 `WindowCenter` 和 `WindowWidth` 进行初始显示，并提供滑块供用户手动调节对比度。

### 模块 B: 骨盆参考系建立 (关键)
*   **B.1 侧位骶骨标定:**
    *   **工具:** 直线工具。
    *   **操作:** 在侧位图画出骶骨板 (Sacral Plate)。
    *   **数据:** 记录两端点 $P_{S1}, P_{S2}$。
*   **B.2 髋臼中心定位:**
    *   **工具:** 双圆工具 (同步显示)。
    *   **操作:** 用户在正、侧位图调整左右两个圆的位置和大小。
    *   **算法:** 结合正位 $X, Y$ 和侧位 $Z, Y$，计算出左右髋臼中心的三维坐标 $H_L, H_R$。
*   **B.3 坐标系构建:**
    *   原点 $O$: $H_L$ 和 $H_R$ 的中点。
    *   建立旋转矩阵 $M_{pelvis}$，消除患者站立时的骨盆旋转误差。后续所有脊柱参数基于此坐标系计算。

### 模块 C: 脊柱初始化
*   **C.1 手动描点:**
    *   用户在正位图点击 T1, T4, T8, T12, L3, L5 中心。
    *   用户在侧位图点击相同椎体中心。
*   **C.2 3D 曲线生成:**
    *   使用 `scipy.interpolate.CubicSpline` 分别拟合 X-Y 和 Z-Y 曲线，合并生成 3D 脊柱中心线 (Centerline)。
*   **C.3 模板加载:**
    *   从 `assets/models/` 读取 T1-L5 的标准 STL/OBJ 模型。
    *   将 17 个椎体模型沿着 Centerline 放置，根据切线方向自动计算初始旋转。

### 模块 D: 精细调整 (核心交互逻辑)
此模块是软件成败的关键。

*   **D.1 投影线框 (Wireframe Projection):**
    *   实时计算：每次 3D 模型变动，将其 Mesh 边缘投影到 2D 平面。
    *   **算法提示:** 仅投影 Mesh 的轮廓点，而非所有点，以优化性能。
*   **D.2 六自由度调整 (Gizmo):**
    *   **UI:** 选中某个椎体后，在 2D 视图旁显示控制面板（或在 3D 视图显示操作轴）。
    *   **功能:**
        1.  **Axial Rotation (轴向旋转):** 即使在 2D 图看不出来，也必须允许调整，这是 Cobb 角准确的关键。
        2.  **Sagittal/Frontal Rotation:** 调整椎体倾斜。
        3.  **Translation:** 微调位置。
    *   **联动:** 调整滑块 -> 更新 3D Mesh 矩阵 -> 重绘 2D 线框。
*   **D.3 整体调整 (Fast Mode):**
    *   提供“区域影响”工具。拖动一个椎体，邻近椎体按高斯衰减权重跟随移动，保持脊柱连续性。

### 模块 E: 临床参数测量
*   **E.1 Cobb 角 (自动):**
    *   计算所有椎体终板法向量在冠状面的投影。
    *   自动寻找局部最大夹角，定义为 Cobb 角。
    *   支持用户手动指定起止椎体 (如 T4-L1)。
*   **E.2 矢状面参数:**
    *   **Kyphosis (胸椎后凸):** T1 上终板与 T12 下终板夹角。
    *   **Lordosis (腰椎前凸):** L1 上终板与 L5 (或 S1) 下终板夹角。
*   **E.3 骨盆参数:**
    *   **PI (Pelvic Incidence):** 垂直于骶骨板中点的线与骶骨中点-髋轴中点连线的夹角。
    *   **SS (Sacral Slope):** 骶骨板与水平面夹角。
    *   **PT (Pelvic Tilt):** PI - SS。

### 模块 F: 导出与报告
*   **F.1 STL 导出 (3D Print Ready):**
    *   将场景中所有调整好的椎体 Mesh + 骨盆 Mesh 合并。
    *   应用当前变换矩阵。
    *   保存为二进制 `.stl` 文件。
*   **F.2 临床报告 (PDF):**
    *   使用 `PyQt6.QtPrintSupport` 或 `reportlab`。
    *   **内容:** 患者信息、正侧位带有测量标注的截图、参数列表 (Cobb, PI, PT, SS)。

---

## 4. 核心算法逻辑 (Algorithmic Appendix)

**开发者必读：EOS 投影几何**

EOS 系统不是普通的透视投影。开发者必须实现名为 `EOSProjection` 的类。

1.  **几何参数:**
    *   $SD$: 光源到探测器距离 (Source to Detector, tag 0018,1110, ~1300mm)
    *   $SI$: 光源到等中心距离 (Source to Isocenter, tag 0018,9402)
    *   $PixelSpacing$: 像素物理尺寸 ($P_x, P_y$)

2.  **投影公式 (3D点 $P(x,y,z)$ 到 2D 像素 $(u,v)$):**
    假设坐标系原点在 Isocenter，Z 轴指向光源。

    *   **垂直方向 (Y):** 平行投影。
        $$v_{mm} = y$$
    *   **水平方向 (X):** 锥形投影 (有放大)。放大率 $M$ 取决于深度 $z$。
        $$M = \frac{SD}{SI - z}$$
        $$u_{mm} = x \cdot M$$

    *   **像素转换:**
        $$u_{pixel} = \frac{u_{mm}}{P_x} + C_x$$
        $$v_{pixel} = \frac{v_{mm}}{P_y} + C_y$$
        ($C_x, C_y$ 为图像中心偏移量)

---

## 5. 数据与资源准备 (Assets Requirement)

**在开发开始前，必须准备好以下资源：**

1.  **3D 模型库 (Atlas):**
    *   来源：使用 VerSe 2020 数据集。
    *   处理：提取正常人的 T1-L5 及 Pelvis。使用 MeshLab 将所有模型的局部坐标原点统一设置在椎体几何中心，Z轴垂直于终板。
    *   格式：`.obj` 或 `.stl` (低多边形 Low-Poly 用于交互，高精度用于导出)。
2.  **测试数据:**
    *   至少 3 套完整的 EOS DICOM 影像 (包含正位+侧位)。
3.  **开发环境准备:**
    *   模型来源：使用VerSe数据集获取标准脊柱模型
    *   格式转换：通过ITK-SNAP将NIfTI文件转换为`.obj`或`.stl`格式
    *   打包测试：第一周使用PyInstaller打包测试，确保VTK和PyQt兼容性

---

## 6. 开发里程碑与验收标准

| 阶段 | 周期 | 目标 | 验收标准 |
| :--- | :--- | :--- | :--- |
| **Phase 1** | Week 1 | **基础架构** | 界面跑通，DICOM 正确显示，支持窗宽窗位调节，能保存/读取空项目文件；通过PyInstaller打包测试，确保基础环境兼容性。 |
| **Phase 2** | Week 2 | **3D 引擎与投影** | 3D 窗口能显示标准脊柱；在 2D 图上能看到 3D 模型的正确投影线框；实现 EOS 投影算法。 |
| **Phase 3** | Week 3 | **交互与初始化** | 能在图上描点，3D 脊柱能自动对齐到描点曲线；骨盆标定工具可用。 |
| **Phase 4** | Week 4 | **精修与测量** | 滑块能控制椎体运动；Cobb 角和骨盆参数实时计算准确；支持撤销操作。 |
| **Phase 5** | Week 5 | **导出与美化** | STL 导出成功；PDF 报告生成；UI 全面美化 (Dark Theme)；无明显 Bug。 |

---

## 7. 给开发者的特别提示

1.  **不要自己写渲染器:** 必须使用 `PyVista`。它处理 VTK 复杂的管线非常简单，能让你专注业务逻辑。
2.  **坐标系陷阱:** DICOM 的坐标系、VTK 的坐标系、Qt 的屏幕坐标系，Y 轴方向往往不一致（有的向上有的向下）。**第一周务必通过画辅助线把坐标系搞清楚**，否则后面全错。
3.  **性能优化:**
    - 在拖动滑块时，不要重新读取 Mesh 文件。应该预先加载到内存，只修改 `Actor` 的 `UserMatrix`。
    - 使用低多边形模型(Low Poly)用于实时交互，高精度模型用于导出
4.  **状态管理:** 所有的关键数据（点坐标、角度）都要保存在一个单例类 `ProjectState` 中，不要散落在各个 UI 文件里。
5.  **旋转表示:** 内部存储使用四元数(Quaternions)或4x4变换矩阵，UI展示使用欧拉角（度数）
6.  **调试技巧:** 在3D视图中画出相机视锥体和像平面，可视化检查投影逻辑
7.  **数学辅助:** 如遇投影矩阵计算困难，可使用pylinac等专业库

---

## 8. 开发环境准备
1.  **模型来源:**
    - 使用VerSe数据集获取标准脊柱模型
    - 通过ITK-SNAP将NIfTI文件转换为`.obj`或`.stl`格式
2.  **打包测试:** 第一周使用PyInstaller打包测试，确保VTK和PyQt兼容性

## 9. 代码实现参考
```python
# STL导出实现
import pyvista as pv

def export_spine_to_stl(vertebrae_actors, output_path):
    combined_mesh = pv.PolyData()
    for actor in vertebrae_actors:
        mesh = actor.mapper.dataset
        matrix = actor.user_matrix
        transformed_mesh = mesh.copy()
        transformed_mesh.transform(matrix)
        combined_mesh = combined_mesh.merge(transformed_mesh)
    combined_mesh.save(output_path, binary=True)
```

```python
# UI初始化示例
import sys
from PyQt6.QtWidgets import QApplication
from qt_material import apply_stylesheet

app = QApplication(sys.argv)
apply_stylesheet(app, theme='dark_teal.xml')
# ...其余界面代码...
```

这份文档现在非常详尽，涵盖了从架构、算法到 UI 细节的所有内容。中级开发者如果按照此文档执行，配合 GitHub Copilot 等工具辅助编写具体代码，完全有能力开发出符合要求的软件。