这是一份为 **Python 中级开发工程师** 量身定制的《PySpine3D 软件详细需求规格说明书 (SRS)》。

这份文档不仅包含功能列表，还拆解了**核心算法逻辑**、**数据结构设计**以及**推荐的代码实现路径**。工程师拿到这份文档后，应当能够明确“第一步做什么，第二步做什么”，以及“难点如何解决”。

---

# PySpine3D 软件需求规格说明书 (v1.0)

**项目名称：** PySpine3D
**目标平台：** Windows Desktop (优先), macOS/Linux
**核心语言：** Python 3.10+
**UI 框架：** PyQt6 / PySide6
**3D 引擎：** PyVista (基于 VTK，比原生 VTK 更易用)

---

## 1. 项目概述 (Overview)

本项目旨在复刻 EOS Imaging 的 `sterEOS` 软件核心功能。软件需加载 EOS 拍摄的 DICOM 正侧位 X 光影像，通过用户交互（或 AI 辅助）构建患者脊柱的 3D 模型，并基于 3D 模型计算 Cobb 角、骨盆参数等临床指标。

**核心价值：** 将 2D 影像转化为 3D 结构，消除投射角度带来的测量误差。

---

## 2. 系统架构 (Architecture)

采用经典的 **MVC (Model-View-Controller)** 模式，但针对图形应用稍作调整：

*   **Model (数据层):**
    *   `PatientData`: 存储 DICOM 标签、像素数据。
    *   `SpineModel`: 存储脊柱 3D Mesh（顶点、面）、每节椎体的位姿矩阵 (Position/Rotation)。
    *   `Landmarks`: 存储用户标记的关键点（骶骨板、髋臼中心）。
*   **View (视图层):**
    *   `MainWindow`: PyQt 主窗口框架。
    *   `SliceViewerWidget`: 2D 图像查看器（显示正/侧位图，处理窗宽窗位）。
    *   `3DViewerWidget`: PyVistaQt 窗口，显示 3D 脊柱模型。
*   **Controller (逻辑层):**
    *   `WorkflowManager`: 管理流程状态（从加载 -> 骨盆标定 -> 脊柱调整 -> 报告）。
    *   `ProjectionEngine`: **(核心)** 处理 3D 坐标到 2D EOS 影像平面的投影数学计算。

---

## 3. 技术栈与库推荐 (Tech Stack)

*   **GUI:** `PyQt6` (界面布局, 事件循环)
*   **3D 渲染:** `pyvista`, `pyvistaqt` (极大简化 3D 交互和 Mesh 操作)
*   **图像处理:** `numpy` (矩阵运算), `pydicom` (读取 DICOM), `opencv-python` (图像缩放/显示辅助)
*   **数学运算:** `scipy` (样条插值 Spline, 空间几何计算)
*   **AI (可选):** `torch` / `onnxruntime` (如果集成自动识别模型)

---

## 4. 核心数据结构与算法 (Core Logic)

**这是开发工程师必须最先理解的部分。**

### 4.1 坐标系定义
1.  **世界坐标系 (World Space / 3D):** 单位 mm。原点 (0,0,0) 定义在两个放射源的等中心 (Isocenter) 或重建后的患者骨盆中心。
    *   X轴：左右
    *   Y轴：上下 (头脚)
    *   Z轴：前后
2.  **图像坐标系 (Image Space / 2D):** 单位 pixel。
    *   Frontal Image (正位图): $U_{front}, V_{front}$
    *   Lateral Image (侧位图): $U_{lat}, V_{lat}$

### 4.2 EOS 投影算法 (关键算法)
EOS 系统的成像原理特殊：**Y 轴是平行投影（扫描），X 轴是透视投影（锥形束）。**

工程师需实现如下投影函数 `project_3d_to_2d(point_3d, view_type)`:

```python
# 伪代码逻辑
def project_eos(point_3d, view_type, geometric_params):
    """
    point_3d: (x, y, z) in mm
    view_type: 'frontal' or 'lateral'
    geometric_params: 包含 SourceToDetector (SD), SourceToIsocenter (SI)
    """
    x, y, z = point_3d
    SD = geometric_params['SD'] # 光源到探测器距离 (~1300mm)
    SI = geometric_params['SI'] # 光源到物体中心距离 (~918mm or 987mm)
    
    # 放大率 M (仅在水平方向存在放大，垂直方向放大率为1)
    # 假设 Z 是深度，对于正位片，Z是前后方向
    Magnification = SD / (SI - z) 
    
    # 投影坐标 (mm)
    u_mm = x * Magnification  # 水平坐标有透视效果
    v_mm = y                  # 垂直坐标是平行投影 (无放大)
    
    # 转换为像素坐标 (基于 PixelSpacing)
    u_pix = u_mm / pixel_spacing_x + image_center_x
    v_pix = image_height - (v_mm / pixel_spacing_y) # Y轴通常翻转
    
    return u_pix, v_pix
```

---

## 5. 功能模块详细需求 (Functional Requirements)

### 模块一：数据加载与环境初始化
*   **FR1.1 读取 DICOM 目录:**
    *   遍历文件夹，读取所有 `.dcm` 文件。
    *   通过 Tag `(0018, 9402)` (Distance Source to Isocenter) 区分正侧位：
        *   值较小 (约 918mm) -> **Frontal (正位)**
        *   值较大 (约 987mm) -> **Lateral (侧位)**
*   **FR1.2 解析几何参数:**
    *   读取 `PixelSpacing`。
    *   读取私有 Tag `(0863, xxxx)` (若解析困难，初期版本允许硬编码标准 EOS 参数或提供 UI 让用户手动微调 SI/SD 参数)。
*   **FR1.3 图像预处理:**
    *   应用 16-bit 转 8-bit 显示映射。
    *   **交互:** 实现“鼠标右键拖动”调整 Window Center / Window Width (W/L)。

### 模块二：骨盆参考系标定 (Pelvic Setup)
*   **FR2.1 侧位骶骨板:**
    *   UI: 在侧位图上允许用户画一条线段。
    *   逻辑: 记录线段两端点 $P_{sacral\_top}, P_{sacral\_bottom}$。
*   **FR2.2 双侧髋臼:**
    *   UI: 在正位和侧位图上同步显示两个圆圈（左/右）。
    *   交互: 用户拖动圆心、滚轮调整半径。
    *   逻辑: 结合正侧位坐标，计算出两个球心在 3D 空间的位置 $Center_{hip\_L}, Center_{hip\_R}$。
*   **FR2.3 建立患者坐标系:**
    *   原点: 双侧髋臼连线中点。
    *   利用上述点位计算旋转矩阵，校正患者站立时的骨盆扭转。

### 模块三：脊柱 3D 初始化 (Spine Initialization)
*   **FR3.1 脊柱中心线绘制:**
    *   **手动模式:** 用户在正、侧位图分别点击 5-7 个点（T1, T4, T8, T12, L3, L5）。
    *   **算法:** 使用 `scipy.interpolate.CubicSpline` 分别拟合正侧位曲线，合并为 3D 空间曲线 (Spinal Curve)。
*   **FR3.2 加载平均模型:**
    *   资源: 准备一套标准脊柱 Mesh 文件（`T1.obj` 到 `L5.obj`，共17个文件），可来自 VerSe 公开数据集。
    *   逻辑: 将这 17 个椎体模型，沿着生成的 3D 脊柱中心线排列、旋转，使得它们像“糖葫芦”一样串在曲线上。

### 模块四：精细调整 (Fine-Tuning) - **核心交互**
*   **FR4.1 椎体选择:**
    *   点击列表或 3D 视图中的椎体，设为“当前激活椎体”。
*   **FR4.2 六自由度调整 (PyQt组件):**
    *   提供滑块或鼠标快捷操作，调整当前椎体的：
        *   位置 (X, Y, Z)
        *   旋转 (Axial, Sagittal, Frontal)
*   **FR4.3 实时投影反馈 (关键):**
    *   当用户调整 3D 椎体时，实时调用 `project_eos` 函数。
    *   在 2D X光图上绘制该椎体的**轮廓线 (Wireframe)**。
    *   **验收标准:** 用户看着 2D 图，旋转 3D 模型，直到 2D 线框与 X 光片中的骨头边缘重合。

### 模块五：参数计算与输出
*   **FR5.1 临床参数计算:**
    *   **Cobb 角:** 选取 T1 上终板法向量与 L5 下终板法向量，投影到冠状面计算夹角。
    *   **Kyphosis/Lordosis:** 矢状面投影夹角。
    *   **骨盆参数:** 基于 FR2 确定的点位计算 PI, PT, SS。
*   **FR5.2 报告生成:**
    *   生成 PDF，包含正侧位截图（带测量线）、参数表格。
    *   使用 `reportlab` 或 `PyQt6.QtPrintSupport` 生成。

*   **FR5.3 STL 模型导出 (3D Printing / External View)**
    *   **功能描述：** 将当前场景中已经调整好位置的所有椎体（T1-L5）及骨盆模型，合并为一个单一的 3D 文件导出。
    *   **文件格式：** `.stl` (二进制格式，兼容性最好) 或 `.obj`。
    *   **逻辑实现：**
        1.  遍历场景中所有激活的 Mesh 对象 (T1_mesh, T2_mesh ... L5_mesh)。
        2.  应用当前的变换矩阵 (Transform Matrix)，确保导出的模型姿态与屏幕显示一致。
        3.  使用 `pyvista.merge()` 将多个 Mesh 合并为一个 `UnstructuredGrid`。
        4.  调用 `.save('patient_spine_model.stl')`。
    *   **用户入口：** 顶部工具栏 "Export" -> "Export 3D Model (.stl)"。
---

## 6. 界面设计 (UI Layout Guide)

建议使用 `QGridLayout` 实现三栏布局：

```text
+---------------------------------------------------------------+
|  Toolbar: Load | Windowing | Pan/Zoom | Reset | Export        |
+----------------------+----------------------+-----------------+
|                      |                      |                 |
|   2D View (Frontal)  |   2D View (Lateral)  |    3D View      |
|                      |                      |  (Interactive)  |
|   [QGraphicsView]    |   [QGraphicsView]    | [QVTKRender]    |
|   Overlay: Wireframe |   Overlay: Wireframe |                 |
|                      |                      |                 |
+----------------------+----------------------+-----------------+
|  Control Panel (Bottom)                                       |
|  [Slider] Axial Rot   [Slider] Sagittal Rot  [Slider] Pos X   |
|  Current Vertebra: [ L4 ]                                     |
|  Calculated Cobb Angle: 24 deg                                |
+---------------------------------------------------------------+
```

---

## 7. 实施路线图 (Implementation Roadmap)

### 第一阶段：基础框架 (Week 1)
1.  搭建 PyQt 主界面。
2.  实现 DICOM 读取器，解析 EOS 几何参数（如果私有 tag 解析失败，先用固定参数 mock）。
3.  实现 2D 图像显示，支持 Windowing (对比度调整)。

### 第二阶段：3D 引擎与投影 (Week 2)
1.  集成 PyVistaQt。
2.  加载单个 `L5.obj` 模型到场景中。
3.  **难点攻关:** 实现 `project_eos` 函数。
4.  在 2D 视图上绘制 `L5.obj` 的投影轮廓（将 3D Mesh 的边提取出来，投影坐标，画在 QGraphicsScene 上）。

### 第三阶段：全脊柱初始化 (Week 3)
1.  实现手动描点（正侧位）。
2.  实现 3D 曲线拟合。
3.  实现“沿曲线批量放置椎体”的算法。

### 第四阶段：交互微调 (Week 4)
1.  绑定滑块事件 -> 更新 3D 模型矩阵 -> 触发重绘投影。
2.  优化性能：确保拖动滑块时，2D 线框跟随无明显延迟（可能需要降低 Mesh 投影时的采样率）。

### 第五阶段：测量与报告 (Week 5)
1.  根据最终模型位姿计算角度。
2.  PDF 导出。

---

## 8. 给开发者的特别提示 (Tips for Dev)

1.  **关于 Mesh 数据:** 不要尝试自己建模。去下载 **VerSe 2019/2020** 数据集，里面有大量分割好的 NIfTI 文件，用 ITK-SNAP 转成 `.obj` 或 `.stl` 作为你的标准模板。
2.  **关于性能:** 如果 `project_eos` 对整个高精度 Mesh 计算太慢，可以生成一套 "Low Poly" (低面数) 的模型用于实时交互，鼠标松开后再渲染高精度线框。
3.  **关于 3D 旋转:** 欧拉角 (Euler Angles) 容易死锁，内部存储建议用 **四元数 (Quaternions)** 或直接存储 **4x4 变换矩阵**，但 UI 上给医生展示欧拉角（度数）。
4.  **调试技巧:** 在 3D 视图中画出“相机视锥体”和“像平面”，可视化地检查你的投影逻辑是否正确。

---

## 9. UI/UX 现代化设计规范 (Modern UI Design)

**目标：** 打造**深色系、沉浸式、专业**的医疗软件界面，减少放射科医生在暗室工作时的眼部疲劳，并提升软件的高级感。

### 9.1 配色方案 (Color Palette) - "EOS Dark" 风格
*   **背景色 (Background):** `#2B2B2B` (深炭灰) —— 用于主窗口背景。
*   **面板色 (Surface):** `#323232` —— 用于侧边栏、工具栏背景。
*   **重音色/品牌色 (Accent):** `#FF9500` (EOS 橙) 或 `#007AFF` (医疗蓝) —— 用于按钮、选中状态、滑块进度条。
*   **文本色 (Text):**
    *   主要: `#FFFFFF` (纯白)
    *   次要: `#B0B0B0` (浅灰)
*   **边框/分割线 (Border):** `#404040`

### 9.2 界面布局与样式 (Layout & Style)
*   **圆角 (Border Radius):** 按钮和输入框采用 `4px - 6px` 圆角，看起来更柔和。
*   **扁平化图标 (Flat Icons):**
    *   **严禁**使用老旧的位图图标。
    *   **推荐:** 使用 `qtawesome` 库 (基于 FontAwesome)，直接在 PyQt 中加载矢量图标。
    *   颜色：默认白色，Hover (悬停) 变亮或变色。
*   **字体 (Typography):**
    *   Windows: `Segoe UI` (10pt / 12pt)
    *   Mac: `SF Pro Display`
    *   **要求:** 必须清晰易读，严禁使用衬线体 (如 Times New Roman)。

### 9.3 推荐使用的 UI 库 (为了让工程师少写 CSS)
不要从零手写所有样式，建议使用成熟的 PyQt 主题库：

*   **方案 A (推荐 - 快速且美观): `qt-material`**
    *   这使得 PyQt 瞬间拥有类似 Material Design 的现代外观。
    *   *安装:* `pip install qt-material`
    *   *代码:*
        ```python
        from qt_material import apply_stylesheet
        # 在 main.py 中只需一行代码应用深色医疗主题
        apply_stylesheet(app, theme='dark_medical.xml')
        ```
*   **方案 B (自定义程度高): `QDarkStyleSheet`**
    *   经典的深色主题，稳重，适合医疗软件。
    *   *安装:* `pip install qdarkstyle`

### 9.4 关键交互细节 (Micro-Interactions)
*   **Hover 效果:** 鼠标悬停在按钮上时，背景色应微微变亮 (`#454545`)，给用户反馈。
*   **3D 视图背景:** 3D 窗口背景不要用纯黑，建议使用**深色渐变** (Gradient)，从顶部的深灰到底部的黑色，这样 3D 模型的空间感更强。
    *   *PyVista 实现:* `plotter.set_background(color="#2b2b2b", top="#1a1a1a")`
*   **布局间距 (Spacing):** 适当增加控件之间的 `Margin` 和 `Padding`，不要让界面看起来密密麻麻。

---

## 给开发工程师的 "Cheat Sheet" (代码小抄)

为了确保工程师能精准实现你的“现代感”和“导出”要求，请把下面这段代码逻辑发给他：

#### 1. 关于 STL 导出逻辑 (Python/PyVista)
```python
import pyvista as pv

def export_spine_to_stl(vertebrae_actors, output_path):
    """
    vertebrae_actors: 字典或列表，包含场景中所有的 VTK/PyVista Actor
    output_path: 保存路径 'result.stl'
    """
    combined_mesh = pv.PolyData()
    
    for actor in vertebrae_actors:
        # 获取 Mesh (PolyData)
        mesh = actor.mapper.dataset
        # 获取当前 Actor 在场景中的变换矩阵 (位置/旋转)
        matrix = actor.user_matrix
        # 复制一份 Mesh 并应用变换，确保导出的是"摆好姿势"的模型
        transformed_mesh = mesh.copy()
        transformed_mesh.transform(matrix)
        
        # 合并
        combined_mesh = combined_mesh.merge(transformed_mesh)
        
    # 保存为二进制 STL (binary=True 减小体积)
    combined_mesh.save(output_path, binary=True)
    print(f"Success: Model exported to {output_path}")
```

#### 2. 关于现代 UI 初始化 (Python/PyQt6)
```python
import sys
from PyQt6.QtWidgets import QApplication, QPushButton, QVBoxLayout, QWidget
# 强烈建议使用 qt_material 快速实现现代感
from qt_material import apply_stylesheet 

app = QApplication(sys.argv)
window = QWidget()

# 应用 'dark_teal.xml' 或 'dark_medical.xml' 主题
# 这会自动处理所有的 按钮圆角、高亮色、深色背景
apply_stylesheet(app, theme='dark_teal.xml')

# 此外，可以使用自定义 QSS 微调特定组件，例如 EOS 橙色按钮
custom_style = """
QPushButton#exportBtn {
    background-color: #FF9500;
    color: white;
    font-weight: bold;
    border-radius: 5px;
    padding: 8px;
}
QPushButton#exportBtn:hover {
    background-color: #FFAA33;
}
"""
app.setStyleSheet(app.styleSheet() + custom_style)

# ... 剩下的界面代码 ...
```

---

**总结：**
这就非常完整了。
1.  **功能上：** 包含了核心的 3D 重建算法、骨盆矫正逻辑、以及最后的 STL 导出。
2.  **视觉上：** 指定了深色医疗风格和具体的技术实现路径。



为了保证软件能用，除了之前的需求文档，必须加上这些：”
文件系统： 实现 Save Project As... 和 Open Project...，保存所有标记点和模型位置矩阵到 JSON 文件。
快捷键系统： 必须支持 Ctrl+Z（撤销）。
日志系统： 加入 loguru 库，把所有报错记录到文件。
打包测试： 第一周就要尝试用 PyInstaller 打包一个 Hello World，确定 VTK 和 PyQt 在你的目标电脑上能跑通，别等到最后打包报错。
数学辅助： 如果遇到投影矩阵算不准，不要死磕，去 GitHub 找现成的库（如 pylinac 或其他放疗相关的 Python 库，它们处理投影很专业）。